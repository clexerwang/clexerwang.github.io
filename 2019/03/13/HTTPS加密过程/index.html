<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>HTTPS加密过程</title><link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css"><link rel="shortcut icon" href="/img/favicon.png"></head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Clexer</a></li><li class="menu-item"><a href="/blog/archives" class="menu-link">Archives</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Clexer</a></li><li class="menu-item"><a href="/blog/archives" class="menu-link">Archives</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li></ul></nav><div id="mobile-menu-toggle" class="toggle-menu"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">HTTPS加密过程</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title">发表于: </span>2019-03-13</p><p class="meta-item meta-category"></p></div><div class="article-content"><p>HTTPS相比HTTP拥有<code>消息加密</code>，<code>身份验证</code>，<code>消息完整性验证</code>等特性。要实现这些特性就需要有一套特定的机制，现在就是说一下实现这些特性的机制。</p>
<p>###1、HTTPS的实现机制</p>
<p>###1-1、消息加密<br>HTTPS中在数据进行发送前会对数据进行加密，加密的方式是<code>对称加密</code>,即对数据进行加密和解密时所使用的密钥相同。那么在消息传递时就要求通信的双方要拥有相同的加密密钥，这样才能保证通信双方可以对收到的消息进行揭秘解密。</p>
<p>但是通信双方如何才能安全的获得这个密钥呢？这就需要使用<code>非对称加密</code>来获得密钥，但是这有一个问题，通信双发如何才能安全的获取到对方的公钥呢？</p>
<p>###1-2、身份验证<br>身份验证表示在进行通信时，通信双方需要使用一定的手段来验证对方的身份。<br>在<code>非对称加密</code>中，当B收到A发来的消息时如果可以使用A的公钥来对消息进行解密，那么就可以确认发送方的确是A。这就可以用来进行对方身份的验证。</p>
<p>但是仍然是这个问题，通信双方如何才能获得对方的公钥呢？</p>
<p>###1-3、消息完整性验证<br>为了保证消息在传输过程中不被篡改，在发送消息时使用MAC算法根据<code>密钥+数据</code>计算出对应的<code>MAC值</code>，并将计算出的MAC值附加在数据后一并发送给对方。当对方接收到消息后同样使用MAC算法根据<code>密钥+数据</code>计算出MAC值(通信双方计算MAC所使用的密钥是相同的)，并将其与消息中的MAC值相比较，如果MAC值相同就说明消息没有被篡改。</p>
<p>通信双方使用非对称加密来获得计算MAC值时所使用的密钥。所以，又是这个问题：它们又如何才能安全的获得对方的公钥呢？</p>
<p>###1-4、利用PKI保证公钥的真实性<br>我怎么才能证明我是我呢？这是一个难题，对于通信双方来说想要自证的确很难，所以我们就有了一个权威的第三方，由他来告诉其他人，你就是你！这个权威的第三方叫做CA，而它用来证明你身份的材料，叫做<code>数字证书</code>。</p>
<p><code>数字证书</code>是一个包含用户公钥和其信息的文件，由CA颁发给用户。当通信双方要获取对方的公钥前，会先互相把自己的证书发送给对方，然后双方分别用<code>PKI</code>来推断该证书的真实性。如果是真的，那么就可以从证书中获取对方的公钥，这样以来就完成了公钥的交换。</p>
<p>###2、HTTPS的具体过程<br>1、先经过三次握手建立TCP链接。</p>
<p>2、SSLClient通过Client Hello消息将它支持的TLS的版本，加密算法，密钥交换算法，MAC算法等信息发送给SSLServer。</p>
<p>3、SSLServer发送Server Hello消息给SSLClient，告诉客户端本次通信所使用的TLS的版本号以及加密算法。</p>
<p>4、SSLServer通过Certificate消息将自己的数字证书发送给SSLClient。</p>
<p>5、SSLServer发送Server Hello Done消息通知SSLClient协商结束，开始进行密钥交换。</p>
<p>6、SSLClient在验证证书合法后，利用证书中的公钥将premaster secret将加密，通过Client Key Exchange消息发送给SSLServer。</p>
<pre><code>SSLclient和SSLserver利用premaster secret计算出同样的主密钥（master secret）。再利用master secret生成用于对称密钥算法、MAC算法等的密钥。
</code></pre><p>7、SSLClient发送Change Ciper Spec消息，通知SSLServer将使用协商好的加密方法进行传输。</p>
<p>8、SSLClient计算已交互的握手消息（除Change Cipher Spec消息外全部已交互的消息）的Hash值，利用协商好的加密方法处理Hash值(计算并加入MAC值，加密)，并通过Finished消息发送给SSLServer。</p>
<p>9、SSLserver发送Change Cipher Spec消息，通知SSLclient将使用协商好的加密方法进行传输。</p>
<p>10、SSLserver计算已交互的握手消息的Hash值，利用协商好的加密方法处理Hash值（计算并加入MAC值、加密），并通过Finished消息发送给SSLClient。</p>
</div></article><div id="base-discus"></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>___ Using </span><a href="https://github.com/chuguixin/Simple"><span>Simple</span></a><span> Presents For You.</span></div></footer><div class="dom-ready"><script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script src="/js/base.js"></script></div></body></html>