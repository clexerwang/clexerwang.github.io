<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><title>History库源码学习</title><link rel="stylesheet" href="/css/layout.css">
<link rel="stylesheet" href="/css/main.css"><link rel="shortcut icon" href="/img/favicon.png"></head><body><header class="base-menu"><div class="menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Clexer</a></li><li class="menu-item"><a href="/blog/archives" class="menu-link">Archives</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li></ul></nav></div></header><header class="base-mobile-menu"><div class="mobile-menu-wrapper"><div class="menu-layout-bg"></div><nav class="menu-content"><ul class="menu-list"><li class="menu-item"><a href="/" class="menu-link">Clexer</a></li><li class="menu-item"><a href="/blog/archives" class="menu-link">Archives</a></li><li class="menu-item"><a href="/about" class="menu-link">About</a></li></ul></nav><div id="mobile-menu-toggle" class="toggle-menu"><span class="menu-bar"></span><span class="menu-bar"> </span><span class="menu-bar"></span></div></div></header><div class="base-content"><div class="base-content-main"><article class="article-main"><h1 class="article-title">History库源码学习</h1><div class="article-meta"><p class="meta-item meta-time"><span class="meta-item-title">发表于: </span>2019-03-13</p><p class="meta-item meta-category"></p></div><div class="article-content"><p>@(React框架知识点)</p>
<p>#history库源码学习<br>history和location中的各个属性都在描述当前的历史记录。在history库中，也是同样的道理，history库所做的就是包装了原来的history对象，它抹平了浏览器之间的差异，同时也提供了一些其他的属性。</p>
<p>history库中每个location对象都有一个key属性，用来唯一标示location，也有一个state属性用来保存信息。</p>
<p>createBrowserHistory函数非常长，但是大部分都是声明函数，抛开声明函数，主要做的事情是：判断是否为浏览器环境，判断是否有history对象，生成初始的location对象并返回一个包含应有属性的history对象。</p>
<p>接下来看一下声明的每个函数的作用：</p>
<p>###getDOMLocation</p>
<pre><code>function getDOMLocation(historyState){
    //为要生成的location对象获取key和state
    const {key,state} = historyState;
    //为要生成的location对象获取对应的路径属性值
    const {pathname,search,hash} = window.location;

    //组合路径
    let path = pathname+search+hash;
    //如果设置了basename，但是路径开头与basename不同，就报错
    warning( !(basename &amp;&amp; hasBasename ( path, basename )),&apos;wrong&apos;);

    //生成的location对象的的path不能包含basename部分
    if(basename) path = stripBasename(path,basename)

    //将获得参数传入createLocation，开始生成location对象
    return createLocation(path,state,key)
}
</code></pre><p>可以看到getDOMLocation主要是为生成location对象作处理参数的工作，每个location对象都有<code>key，state，pathname，search，hash</code>这些属性。<code>key</code>和<code>state</code>就来自于当前html中的history的state中。<code>pathname，search，hash</code>来自于当前html中的location的路径信息中，而且这个路径不包含basename部分。</p>
<p>###createLocation<br>createLocation函数比较长，不过内容比较简单</p>
<pre><code>function createLocation(path,state,key,currentLocation){
    let location; //新的历史记录的location对象

    //如果传入的路径信息不是对象类型，就是用parsePath将它拆成对象形式
    if(typeof path === &apos;string&apos;){
        location = parsePath(path);
        location.state = state;
    }else{
        //如果是对象形式的，直接解构
        location = {...path};

        if(location.pathname === undefined ) location.pathname = &apos;&apos;;

        if(location.search){
            if(location.search.charAt(0)!== &apos;?&apos;){
                location.search = ? + location.search;
            }
        }else{
            location.search = &apos;&apos;;
        }                

        if(location.hash){
            if(location.hash.charAt(0) !== &apos;#&apos;){
                location.hash = &apos;#&apos;+location.hash;
            }
        }else{
            location.hash = &apos;&apos;;
        }
        //如果有state，就设置location的state
        if(state !== undefined &amp;&amp; location.state === undefined){
            location.state = state;
        }
    }
    try{
        location.pathname = encodedURI(location.pathname)
    }catch(e){
        throw e;
    }

    //currentLocation存在，说明将要从一个历史记录跳转到一个新的历史记录，
    if(currentLocation){
        //不知道location.pathname为空是什么情况
        if(!location.pathname){
            location.pathname = currentLocation.pathname;
            //如果新的pathname不是以‘/’开头
        }else if(location.pathname.charAt(0) !== &apos;/&apos;){
            //根据新的pathname使用resolvePathname计算新的路径
            location.pathname = resolvePathname(location.pathname,currentLocation.pathname)
        }
    }else{
        if(!location.pathname){
            location.pathname = &apos;/&apos;;
        }
    }

    return location;

}
</code></pre><p>createLocation函数主要就是处理路径的问题，可以看到location对象有pathname，search，hash，key，state这几个属性。</p>
<p>###createTransitionManager<br>createTransitionManager函数主要是负责对路径变化的监听函数进行管理，它返回一个对象拥有setPrompt，confirmTransitionTo，appendListener，notifyListeners方法，分别用来添加提示信息，管理拦截信息的显示，添加监听路由变化的函数，执行监听函数。</p>
<pre><code>function createTransitionManager(){
    let prompt = null;
    //prompt指要显示的提示信息，可以是函数或者字符串类型。
    const setPrompt = function(nextPrompt){
        warning(prompt == null,&apos;warning&apos;);

        prompt = nextPrompt;
        //返回可以取消prompt的函数
        return ()=&gt;{
            if(prompt === nextPrompt) prompt = null;
        }
    }

    //主要用来显示提示信息，并进行路由的跳转
    //getUserConfirm就是用来显示提示信息的函数，默认使用window.confirm
    //callback是显示完提示信息后的执行的函数
    const confirmTransitionTo = function(location,action,getUserConfirm,callback){
        if(prompt !== null){
            //如果prompt是函数类型，那就执行prompt获得要显示的提示信息。
            const result = typeof prompt === &apos;function&apos;?prompt(location,action):prompt;

            //如果提示信息是字符串类型（可以直接显示）
            if(typeof result === &apos;string&apos;){
                //判断有没有显示提示信息的函数
                if(typeof getUserConfirmation === &apos;function&apos;){
                    //在getUserConfirmation中会执行callback
                    getUserConfirmation(result,callback)
                }else{
                    //如果传入了提示信息，但是没有显示提示信息的函数，则报错
                    warning(false,&apos;warning&apos;);
                    //执行回调函数，一般回调函数的作用都是用来进行路由跳转的
                    callback(true);
                }
            }else{
                //如果要显示的信息不是字符串类型，但不是空值，那么也可以进行跳转
                //也就是说可以通过控制prompt的返回值来控制页面是否跳转
                callback(result !== false);
            }
        }else{
            //如果prompt是空，说明不需要显示提示信息，那么直接跳转
            callback(true);
        }
    }

    //存储监听路由变化函数
    let listeners =[];

    //插入监听函数
    const appendListener = function(fn){
        //判断该监听函数能否执行，主要是防止监听函数之间相互取消
        let isActive = true;

        let listener = (...args)=&gt;{
            if(isActive) fn(...args)
        }

        listeners.push(listener);
        //返回取消监听函数的函数
        return function(){
            isActive = false;
            //将被取消的监听函数从listeners中筛掉
            listeners = listeners.filter(eve=&gt;eve !== listener)
        }
    }

    const notifyListeners=function(...args){
        listeners.forEach((listener)=&gt;listener(...args))
    }

    return {
        setPrompt,
        confirmTransitionTo,
        appendListener,
        notifyListeners
    }
}
</code></pre><p>###handlePopState<br>看名字就可以猜到，这是popState事件的处理函数</p>
<pre><code>function handlePopState(event){
    //判断是否是无关的popState事件，按照isExtraneousPopstateEvent代码的意思
    //只有事件的state为undefined且不是ios上的chrome时才返回true。
    //也就是说首先是通过事件的state属性来判断是否是一个无关的popState事件，但是ios平台的chrome是一个例外，即使state是undefined也不是无关的事件
    if(isExtraneousPopstateEvent(event)) return;
    //开始处理popState事件,这里使用getDOMLocation生成了新的location对象
    handlePop(getDOMLocation(event.state))    
}
</code></pre><p>###handlePop<br>处理popState事件的主函数</p>
<pre><code>function handlePop(location){
    //forceNextPop表示是否跳过block，直接执行监听函数
    if(forceNextPop){
        forceNextPop = false;
        //执行监听函数，这里并没有传入新的action和location，所以并不能更新history
        setState()；
    }else{
        //由于是处理的popState事件，所以action是POP
        const action = &apos;POP&apos;;

        transitionManager.confirmTransitionTo(location,
                                              action,
                                              getUserConfirmation,
                                              //根据prompt的返回值决定是否进行跳转
                                              function(ok){
                                                    if(ok) setState({action,location})
                                                    else revertPop(location)
                                              })

    }
}
</code></pre><p>###setState</p>
<pre><code>const setState = function(nextState){
    //在路由发生跳转时，使用nextState更新history对象中的属性,主要是更新location和action属性
    //location是当前的path，action表示来到当前路径的动作是什么(POP,PUSH,REPLACE)        
    Object.assign(history, nextState);

    history.length = globalHistory.length;
    //依次执行每个监听函数，传入当前的location对象和action对象
    transitionManager.notifyListeners(history.location, history.action);
  };    
</code></pre><p>###revertPop<br>    //fromLocation表示从哪来，toLocation表示要到哪里去<br>    //revertPop函数是当prompt返回false时执行的，也就是跳转失败<br>    //fromLocation是本来要跳转到的location，由于跳转失败所以需要再跳转回现在的location<br>    function revertPop(fromLocation){<br>        //只有当跳转成功时才会执行setState更新history中的location和action<br>        //所以现在history.location中仍然是跳转前的location<br>        const toLocation = history.location;<br>        //找到跳转前的location在数组中的位置<br>        let toIndex = allKeys.indexOf(toLocation.key);</p>
<pre><code>    //判断两个location是否至少有一个存在且互不相等
    if (toIndex === -1) toIndex = 0;
    let fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;

    const delta = toIndex - fromIndex;
    //如果至少有一个存在且互不相等
    if (delta) {
      //忽略block，立即跳转
      forceNextPop = true;
      go(delta);
    }
};
</code></pre><p>###go<br>go函数就是原生的history.go方法</p>
<pre><code>function go(delta){
    globalHistory.go(delta);
}
</code></pre><p>其余的还有goBack，goForward方法</p>
<p>###checkDOMListeners</p>
<pre><code>//其中的handleHashChange函数，用于处理IE10和IE11在hash改变时，不能触发popstate事件的备选方案
function checkDOMListeners(n){
    listenerCount += n;

    if (listenerCount === 1) {
        //在window上绑定popstate事件的处理函数handlePopState
        window.addEventListener(PopStateEvent, handlePopState);

    if (needsHashChangeListener)
        //在window上绑定hashChange事件的处理函数handleHashChange
        window.addEventListener(HashChangeEvent, handleHashChange);

    } else if (listenerCount === 0) {
        window.removeEventListener(PopStateEvent, handlePopState);

    if (needsHashChangeListener)
        window.removeEventListener(HashChangeEvent, handleHashChange);

    }
}
</code></pre><p>checkDOMListeners函数要做的就是管理事件处理函数。通过传入的n来增减事件处理函数。</p>
<p>###block<br>block函数主要用来给页面添加提示信息，添加了提示信息后的页面即相当于被‘block’了。</p>
<pre><code>function block(prompt=false){
    //通过setPrompt添加提示信息
    const unblock = transitionManager.setPrompt(prompt);

    //通过isBlocked判断当前是否已经绑定了事件处理程序
    if (!isBlocked) {
        //绑定事件处理程序，这样当页面触发了popState或hanshState事件时，就会执行对应的事件处理函数
        checkDOMListeners(1);
        //isBlocked表示当前页面已经添加了提示信息和事件处理程序
        isBlocked = true;
     }

     return () =&gt; {    
         if (isBlocked) {
             //重置isBlocked
             isBlocked = false;
             //移除事件处理程序
             checkDOMListeners(-1);
         }
         //清除prompt
         return unblock();
      };
}
</code></pre><p>可以看到block函数做了两个事情，添加提示信息，绑定事件处理程序。这两个事情是不相关的，setPrompt只是单纯的添加提示信息，checkDOMListeners只是为页面添加事件处理函数，只是在事件处理函数中如果发现页面添加了提示信息那么会根据提示信息的返回值确定是否要跳转，如果没有添加提示信息，那么就直接跳转。</p>
<p>###listen</p>
<pre><code>function listen(listener){
    //listener放入监听数组中，返回一个可以取消监听函数的回调
    const unlisten = transitionManager.appendListener(listener);
    //为当前页面添加事件处理函数
    checkDOMListeners(1);


    return () =&gt; {
        checkDOMListeners(-1);
        unlisten();
    };
}
</code></pre><p>listen函数和block函数的作用类似，都为当前页面添加了popState或hashState的事件处理程序，不同点是block还添加了提示信息，而listen没有。</p>
<p>其实看完了上面这些函数应该就明白了页面跳转的大致流程：在页面渲染时就会执行一些函数，比如执行block或listen为页面添加事件处理函数和监听函数，block函数就使用了setPrompt为页面添加了跳转时的提示信息，当页面要进行跳转时，就会触发popState或hashState事件，这时就会执行事件处理函数，在事件处理函数中会先生成一个新的location对象，然后判断是否要显示提示信息，在显示完提示信息后根据提示信息的返回值判断是否要跳转，在确定要跳转后执行setState，setState会依次执行所有的监听函数，进行页面跳转。</p>
</div></article><div id="base-discus"></div></div></div><footer class="base-footer"><div class="footer-wrapper"><span>___ Using </span><a href="https://github.com/chuguixin/Simple"><span>Simple</span></a><span> Presents For You.</span></div></footer><div class="dom-ready"><script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script src="/js/base.js"></script></div></body></html>